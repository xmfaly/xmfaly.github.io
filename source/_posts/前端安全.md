---
title: 前端安全  
date: 2018-9-20 15:50:16   
tags:   
cover: /img/cover/cover-1
---

虽然现在的浏览器和框架对这方面防范已经很完善了，基本都遇不到了，但是面试还是会问啊。

### XSS
跨站脚本攻击（Cross-site scripting,简称XSS）。恶意使用者可以把脚本注入到网页上，其他使用者在观看网页时及就会受到影响。
#### 如何攻击
通过修改HTML节点或执行JS代码来攻击网站  
例如，HTML中某部分从URL中获取的  
`http://www.domain.com?name=<script>while(1);</script>`
```html
<div>{{ name }}</div>
```
或者攻击者写了一篇包含攻击代码的文章，浏览文章的用户都会被攻击到，这种攻击的打击面更广。
#### 如何防范
最简单的办法就是转义输入输出的内容，对引号，尖括号，斜杠的危险内容进行转义。
```js
function escape(str) {
    str = str.replace(/&/g, '&amp;');
    str = str.replace(/</g, '&lt;');
    str = str.replace(/>/g, '&gt;');
    str = str.replace(/"/g, '&quto;');
    str = str.replace(/'/g, '&##39;');
    str = str.replace(/`/g, '&##96;');
    str = str.replace(/\//g, '&##x3F;');
    return str;
}
```
当然这样也会把需要的格式也转义掉。如果需要的话可以通过添加白名单，或者黑名单进行选择性转义。
##### CSP
内容安全策略[CSP](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP)是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。  
CSP通过指定有效域——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除XSS攻击所依赖的载体。一个CSP兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本 (包括内联脚本和HTML的事件处理属性)。  
可以使用  `Content-Security-Policy` HTTP头部 来指定策略
- 所有内容均来自站点的同一个源
    ```js
    Content-Security-Policy: default-src 'self'
    ```
- 内容来自信任的域名及其子域名
    ```js
    Content-Security-Policy: default-src 'self' *.trusted.com
    ```
- 允许网页应用的用户在他们自己的内容中包含来自任何源的图片, 但是限制音频或视频需从信任的资源提供者(获得)，所有脚本必须从特定主机服务器获取可信的代码
    ```js
    Content-Security-Policy: default-src 'self'; img-src *; media-src media1.com media2.com; script-src userscripts.example.com
    ```
### CSRF
跨站请求伪造（Cross site request forgery）是一种挟制用户在当前已经登录过的网站上执行非本意的操作的攻击方法。简单点说，CSRF就是利用用户登录状态发起恶意请求。
#### 如何攻击
假如网站中有一个通过get请求提交的接口，那么攻击者就可以在钓鱼网站中利用图片进行攻击
```html
<img src="http://www.domain.com?xxx='xxx'" />
```
如果是post相对麻烦一点
```html
<form action="http://www.domain.com" method="post">
    <input name="xxx" value="xxx" type="hidden">
</form>
```
#### 如何防御
遵循以下原则
- get请求只能访问数据不能对数据进行修改
- 禁止第三方网站访问到用户Cookie
- 阻止第三方网站请求接口
- 请求是附带验证信息，比如验证码或token等

##### SameSite
可以对Cookie设置SameSite属性，该请求设置Cookie不随跨域请求发送。  
或者直接禁止跨域发送token
##### 验证Referer
验证Rederer判断是否为第三方网站发起的
##### Token
服务端发放一个Token，每次发请求是携带Token，服务端验证Token是否有效
### 密码
密码一般是后端处理的
#### 加盐
密码的存储不能使用明文直接存储在数据库中，否则一旦数据库泄露会对用户造成很大的损失。
通常需要要对密码进行加盐，然后进行几次不同的加密算法进行加密，因为单纯的加密可以使用彩虹表破开。  
加盐并不能阻止恶意攻击者暴力破解用户密码，但能减少数据库泄露带来的损失。
#### 暴力破解限制
- 可以限制用户登陆的尝试的次数
- 提示用户用户名或密码错误，不要只是提示密码错误
#### 前端加密
前端加密意义不是很大，因为前端代码用户都能看到，但可以预防中间人攻击的过程中明文密码被窃取。

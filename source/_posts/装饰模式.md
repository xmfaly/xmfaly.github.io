---
title: 装饰模式
date: 2017-12-15 20:49:04
tags:
---
装饰器模式适用于为一个对象额外动态的添加功能，每一个具体的装饰类都是一个功能。
类图如下
![image.png](/img/8297579-ce3bbbdebf96766e.png)

1.ConcretConponent是需要被装饰的类，ConcretDecorator是装饰类，他们有一个共同的父类Component。
2.ConcretDecorator中有ConcretConponent类的引用。
3.ConcretDecorator中的operation()中执行ConcretConponent的operation()并添加新的功能。
举个例子，一个游戏人物可以学习技能，这个游戏任务就是ConcretConponent，技能就是ConcretDecorator。

首先定义这个游戏的角色 Role
```
public interface Role {
    void learnSkill();
}
```
定义需要具体被装饰的角色
```
public class Warlock implements Role {
    public void learnSkill() {
        System.out.println("术士学习了以下几个技能");
    }
}
```
定义ConcretDecorator
```
public class Skill implements Role {

    private Role role;

    public void learnSkill() {
        if (role != null) {
            role.learnSkill();
        }
    }

    public Skill(Role role) {
        this.role = role;
    }
}

```

定义三个具体的技能A B C
```
public class Skill_A extends Skill {

    public Skill_A(Role role) {
        super(role);
    }

    @Override
    public void learnSkill(){
        super.learnSkill();
        System.out.println("学习了技能 A");
    }
}

public class Skill_B extends Skill{

    public Skill_B(Role role) {
        super(role);

    }

    @Override
    public void learnSkill(){
        super.learnSkill();
        System.out.println("学习了技能 B");
    }
}

public class Skill_C extends Skill{
    public Skill_C(Role role) {
        super(role);
    }

    @Override
    public void learnSkill() {
        super.learnSkill();
        System.out.println("学习了技能 C");
    }
}
```
编写测试
```
        Role r = new Warlock();
        Skill a = new Skill_A(r);
        Skill b = new Skill_B(a);
        b.learnSkill();
```
结果
```
术士学习了以下几个技能
学习了技能 A
学习了技能 B
```


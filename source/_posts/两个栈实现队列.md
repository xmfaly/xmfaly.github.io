---
title: 两个栈实现队列
date: 2018-02-27 03:37:05
tags:
---
2018年3月23更新
经学弟提醒入队的时候并不需要保证栈2为空，可以存在两个栈同时不空的情况。对于栈2的处理不变，栈1直接入栈即可。如果按照原答案的话，出队需要都移到栈2，入队需要都移到栈1，如果反复出队一个，入队一个就会浪费大量时间在移动数据上。
```
public void push(int node) {
    stack1.push(node);
}
```
以下为原博文
假设使用栈1作为入栈缓冲区，栈2作为出栈缓冲区，那么入栈和出栈的时候所有的可能性有以下三种情况

|         |            |   | |
| ------------- |:-------------:| -----:|  -----:|
| 栈1     | 空 | 	非空 | 空 |
| 栈2      | 空     |  	空 | 非空 |

因为每次都是要弹出某个栈顶或栈底的元素因此并不存在两个栈同时非空的情况。
栈1栈2同时为空的时候入队时直接压入栈1即可，栈1非空栈2空时同样直接压入栈1即可，栈1空栈2非空需要把栈2中的元素全部退回到栈1中然后压如栈1.
出队时同样的道理。
如果栈1栈2都为空，没有元素无法出栈，如果栈2非空，栈1空，直接弹出栈2顶端元素即可，如果栈1非空，栈2空需要把栈1的元素全部压入栈2，然后弹出栈2顶端元素即可。
```
Stack<Integer> stack1 = new Stack<Integer>();
Stack<Integer> stack2 = new Stack<Integer>();

public void push(int node) {
    if(stack2.isEmpty()){
        stack1.push(node);
    }else {
        while(!stack2.isEmpty()){
            stack1.push(stack2.pop());
        }
        stack1.push(node);
    }
}

public int pop() {
    if(!stack2.isEmpty()){
        return stack2.pop();
    }else {
        while(!stack1.isEmpty()){
            stack2.push(stack1.pop());
        }
        return stack2.pop();
    }
}
```
